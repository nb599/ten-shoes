export type PostMeta = {
  slug: string
  title: string
  description: string
  date: string
  readingTime: string
  tags: string[]
  content: string // 添加 content 字段
}

export const posts: PostMeta[] = [
  {
    slug: "ai-features-in-frontend",
    title: "将 AI 能力引入前端：从数据流到体验的完整落地指南",
    description: "如何在前端中安全、稳定且高效地接入大模型：数据流、流式 UI、函数调用、缓存与可观测性。",
    date: "2025-08-10",
    readingTime: "12 min read",
    tags: ["AI", "Front-End", "RSC", "Streaming"],
    content: `# 将 AI 能力引入前端：从数据流到体验的完整落地指南

> 这是一篇面向工程实践的文章，讨论如何稳妥地把大模型能力接入 Web 前端，覆盖数据流、UI 模式、函数调用、缓存与可观测性。所有示例以 Next.js App Router 为参考。

## 1. 能力边界与系统切分

- 前端擅长：交互编排、流式展示、状态管理、可视化与可回放。
- 服务端擅长：鉴权、配额、审计、敏感信息存储、模型聚合与重试。
- 经验法则：**前端不直连模型**，通过服务端 Proxy（如 AI Gateway 或自建 Router）进行调用与观测，降低泄露与绕桶风险。

## 2. 数据流与 UI：流式一等公民

为什么要流式？
- 降低感知延迟，提升完成前反馈。
- 支持**可中断**与**思维展开**（Chain-of-Thought 可控显隐）。
- 支持 token 级"打字机"效果、差量 patch、逐步可用。

前端注意：
- 对齐"中止"与"清理"语义。AbortController 统一取消。
- 针对移动端弱网，逐段渲染 + 错误块内聚（每段可重试）。

## 3. 函数调用 vs. 工具调用

- 统一函数签名（JSON Schema）并在前端做**静态可视化**（参数面板、示例）。
- 函数调用的可回放：把"自然语言意图 + 工具调用参数 + 结果"持久化，作为诊断与 A/B 的基线。

前端落地要点：
- 工具调用日志卡片化（Timeline）。
- 失败重放：保留最近一次参数快照，支持单步 Retry。

## 4. RSC 与边缘：让数据离用户更近

- 使用 Server Components 进行首屏拼装，减少水合负担。
- 把"模型调用"放到**边缘**（Edge/Region）以降低时延，但要评估配额和冷启动。
- 对静态段落（如"提示词建议"、"常见 Q&A"）使用 ISR 或静态导出。

## 5. 体验范式

- Draft-then-commit：先给粗略答案，随后"补丁式完善"。
- Intent Folding：把用户的冗长输入折叠成"核心意图卡片"。
- 懒加载的知识：引用证据块（Sources）按需展开，避免噪音。

## 6. 可靠性与可观测性

- 记录每次会话的 traceId，串联前端与后端日志。
- 关键指标：延迟分布、失败率、工具调用成功率、平均轮数、内容长度。
- 前端埋点：渲染段耗时、取消率、重试率、滚动阅读深度。

## 7. 缓存策略

- Prompt 片段与少量静态资源可本地缓存（IndexedDB）。
- 对结果页面启用 ISR；对用户私有数据不缓存。
- 语义搜索结果需要**命中版本**，避免仓库变更引起语义漂移。

## 8. 风险与合规

- 前端不存储密钥，使用服务器端路由转发并加上速率限制。
- 对敏感输入做本地提示（如"包含隐私信息"）并提供匿名化建议。
- 给出"模型局限"声明，提供反馈渠道。

## 9. 小结

将 AI 能力引入前端的关键，不是"能不能调用"，而是**体验、可回放与可靠性**。把"流式、可中断、可重试、可观测"当作一等公民，才能让应用在真实环境中跑得稳、成长得快。`,
  },
  {
    slug: "agent-ui-patterns",
    title: "Agent UI 设计模式：前端如何承载自治代理",
    description: "总结 8 个 Agent 交互与可视化模式：多工具调用、任务树、可回放对话、可中断与纠错。",
    date: "2025-08-10",
    readingTime: "14 min read",
    tags: ["Agent", "UX", "Observability", "Patterns"],
    content: `# Agent UI 设计模式：前端如何承载自治代理

> 当应用从"对话"走向"自治代理（Agent）"，UI 的复杂度陡增：多工具调用、长任务、权限确认、可回放与纠错。本篇总结 8 个常用的 UI 模式与工程实践。

## 1. 任务树（Task Tree）

- 把复杂任务拆分为子任务，树形展示依赖关系与执行状态（等待、运行、成功、失败）。
- 支持**节点级**重试与跳过；失败节点就地展示错误与建议。

## 2. 工具调用时间线（Tool Timeline）

- 每次工具调用以卡片展示：输入参数、关键日志、输出摘要。
- 对敏感工具（如外部 API 或文件系统）加入权限确认（Just-in-time Consent）。

## 3. 流式进度与里程碑

- 长任务以"里程碑"而非百分比呈现，匹配 Agent 的非线性推进。
- 结合**乐观更新**与"回滚提示"，让用户随时可以中断或撤销。

## 4. 可回放与审计

- 把"自然语言意图 + 计划 + 工具参数 + 结果"序列化存档。
- 为每次运行生成 permalink，方便分享与复盘。

## 5. 纠错与人类介入（Human-in-the-loop）

- 失败时提供"最小可编辑单元"让用户纠偏（如仅修改 API 参数）。
- 支持"从某一步重新开始"，减少无谓重复。

## 6. 资源引用与证据链接

- 为每次工具调用的输入/输出保留引用链接，方便定位源头。
- 前端对资源进行**类型化**展示（代码、图表、图片、表格）。

## 7. 失败优先的可视化

- 把失败作为一等视图：可筛选、聚合错误原因、显示最近波动。
- 异常块可**单独重试**，不要强迫用户全量重跑。

## 8. 组织协作与权限

- 任务可共享给团队成员；可见性与编辑权限区分。
- 对外共享链接默认**只读**，敏感字段打码。

---

## 实施建议

- 从"可视化工具调用"开始，而非一次性引入全部模式。
- 前端与后端共享一个"调用事件协议"，保证事件的稳定性与可扩展性。
- 做好"取消、超时、重试"三件套；对每个工具设定**幂等策略**。`,
  },
]

export function getPostBySlug(slug: string) {
  return posts.find((p) => p.slug === slug) || null
}
